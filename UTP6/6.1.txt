Rozwi¹zania zadañ nale¿y pokazaæ osobiœcie na nastêpnych zajêciach!


Java i bazy danych (JDBC)

U¿ywana w zadaniach przyk³adowa baza danych ksi¹¿ek zrealizowana jest w Derby. Pliki zawieraj¹ce przyk³adowe dane AUTOR.TXT, POZYCJE.TXT, WYDAWCA.TXT oraz pliki konfiguracyjne/skrypty s¹ dostêpne tu. Nale¿y stworzyæ bazê danych Derby uruchamiaj¹c plik wsadowy createdb.bat (modyfikuj¹c ewentualnie JAVA_HOME - katalog instalacyjny Javy, DERBY_HOME - katalog instalacyjny Derby, DERBY_SYSTEM_HOME - katalog w którym znaduj¹ siê bazy danych) o nastêpuj¹cej postaci:

 connect 'jdbc:derby:ksidb;create=true';

drop table POZYCJE;
drop table AUTOR;
drop table WYDAWCA;


create table AUTOR (
        AUTID integer not null generated by default as identity,
        NAME varchar(255) not null,
        PRIMARY KEY(AUTID)
        );

create table WYDAWCA (
        WYDID integer not null generated by default as identity,
        NAME varchar(255) not null,
        PRIMARY KEY(WYDID)
        );


CALL SYSCS_UTIL.SYSCS_IMPORT_TABLE (null,'AUTOR','AUTOR.TXT',null,null,null,0);
CALL SYSCS_UTIL.SYSCS_IMPORT_TABLE (null,'WYDAWCA','WYDAWCA.TXT',null,null,null,0);

create table POZYCJE (
        ISBN char(13) not null,
        AUTID integer not null,
        TYTUL varchar(255) not null,
        WYDID integer not null,
        ROK integer not null,
        CENA real,
        PRIMARY KEY(ISBN),
        FOREIGN KEY(AUTID) REFERENCES AUTOR(AUTID),
        FOREIGN KEY(WYDID) REFERENCES WYDAWCA(WYDID)
        );

CALL SYSCS_UTIL.SYSCS_IMPORT_TABLE (null,'POZYCJE','POZYCJE.TXT',null,null,null,0);

DBLETY

Proponowane "deblety" s¹ krótkimi programikami æwiczeniowymi pokazuj¹cymi podstawowe dzia³ania z bazami danych z poziomu Javy. Tutaj pokazane s¹ czêœciowe programy, które nale¿y uzpe³niæ, tak by w³aœciwie dzia³a³y.

Zadanie 10 (2p)
(£¹czenie z baz¹ danych i uzyskiwanie metainformacji o bazie danych)

Program pokazuje, ¿e do po³¹czenia z BD potrzebne s¹ dwa kroki:
- za³adowanie odpowiedniej klasy sterownika
- uzyskanie po³¹czenie poprzez uzyskanie obiektu typu Connection
Od obiektu Connection mo¿emy otrzymaæ metainformacje zwi¹zane ze sterownikiem, systemem zarz¹dzania BD i sam¹ BD poprzez  uzyskanie obiektu typu DatabaseMetaData, który mo¿emy odpytywaæ za pomoc¹ wielu  metod interfejsu DatabaseMetaData.
Nale¿y napisaæ program, ³¹cz¹cy siê z baz¹ danych ksi¹¿ek i uzyskuj¹cy niektóre informacje o bazie danych.

a. Czêœciowy gotowy program (bez czêœci odpowiedzialnej za po³¹czenie z baz¹ Derby w trybie embedded i uzyskanie metainformacji) jest pokazany poni¿ej. Nale¿y go uzupe³niæ o brakuj¹ce fragmenty kodu.
 import java.sql.*;
import java.lang.reflect.*;


public class Con1  {


 // .... tu czegoœ brakuje

 public Con1()  {
   // ... i tu rownie¿
 }

// Metoda raportuj¹ca informacje zebrane w DatabaseMetaData
// w wywo³aniach metody info podano jako argumenty nazwy metod tego interfejsu
// a w metodzie info korszystamy z metod refleksji;
// ten sposób oprogramowania jest zaawansowany, ale wygodny, bo du¿o mniej pisania
// i kod jest bardziej klarowny
// klauzula throws SQLException mówi o tym, ¿e w trakcie dzia³ania reportInfo mo¿e powstaæ wyj¹tek
// SQLException, ale nie bêdziemy go tu obs³ugiwaæ, obs³ugê przeka¿emy do miejsca wywo³ania
// czyli bloku try w konstruktorze

void reportInfo() throws SQLException {

   info("getDatabaseProductName");
   info("getDatabaseProductVersion");
   info("getDriverName");
   info("getURL");
   info("getUserName");

   info("supportsAlterTableWithAddColumn");
   info("supportsAlterTableWithDropColumn");
   info("supportsANSI92FullSQL");
   info("supportsBatchUpdates");
   info("supportsMixedCaseIdentifiers");
   info("supportsMultipleTransactions");
   info("supportsPositionedDelete");
   info("supportsPositionedUpdate");
   info("supportsSchemasInDataManipulation");
   info("supportsTransactions");

   System.out.println("ResultSet  TYPE_SCROLL_INSENSITIVE :" +
       md.supportsResultSetType(ResultSet.TYPE_SCROLL_INSENSITIVE));
   System.out.println("ResultSet  TYPE_SCROLL_SENSITIVE :" +
       md.supportsResultSetType(ResultSet.TYPE_SCROLL_SENSITIVE));
   System.out.println("insertsAreDetected :" +
       md.insertsAreDetected(ResultSet.TYPE_SCROLL_INSENSITIVE));
   System.out.println("updatesAreDetected :" +
       md.updatesAreDetected(ResultSet.TYPE_SCROLL_INSENSITIVE));
 }

// Metoda info korzysta z metod refleksji do wywo³ania metod podanych "przez" nazwy.
 void info(String metName) {
   Class mdc  = DatabaseMetaData.class;
   Class[] paramTypes =  { };
   Object[] params =  { };
   String infoTyp;
   if (metName.startsWith("get"))
     infoTyp = metName.substring(3,metName.length());
   else infoTyp = metName;
   try  {
     Method m = mdc.getDeclaredMethod(metName, paramTypes);
     System.out.println(infoTyp + ": " + m.invoke(md, params));  // dynamiczne wywo³anie metody
   } catch(Exception exc)  {   // Mo¿liwe powody wyj¹tków: nie ma takiej metody, niew³aœciwe wywo³anie
     System.out.println(exc);
   }
 }

  public static void main(String[] args)  {
   new Con1();
 }
 
b. Zmodyfikuj program z wyk³adu Java i bazy danych (JDBC), rozdzia³ 16 do po³¹czenia z baz¹ Derby w trybie klient-serwer (wymaga startu serwera Derby).

Zadanie 11 (2p)
(Tworzenie tabeli)

Uwaga: Przed wykonaniem tego zadania nale¿y zrobiæ kopiê bazy.

Przyk³ad pokazuje nastêpuj¹ce wa¿ne kwestie:
polecenia DDL lub SQL s¹ wykonywane za poœrednictwem obiektu typu Statement
obiekt Statement uzyskujemy od obiektu Connection za pomoc¹ zlecenia createStatement()
wszelkie zmiany w bazie danych (w tym usuwanie i tworzenie tabel) wykonujemy za pomoc¹ metody executeUpdate aktywowanej na rzecz obiektu Statement
 "na tym samym" obiekcie Statement mo¿emy wykonaæ dowolnie wiele poleceñ SQL/DDL
od obiektu typu SQLException (wyj¹tku SQL) mo¿emy siê dowiedzieæ wielu rzeczy np. o standardowy "SQL State" lub zale¿ny od dostawcy RDBMS kod b³êdu.
Zadanie: utworzyæ tabelê AUTOR z kolumnami: 
AUTID (ca³kowitoliczbowy klucz pierwotny)
NAME (³añcuch znakowy zmiennej d³ugoœci o maks. 255 znakach) – nazwisko/a autora/ów.

Napisaæ program w taki sposób, by zawsze (niezale¿nie od tego czy ju¿ w bazie istnieje tabela AUTOR) by³a tworzona nowa tabela.
Uwaga: tabela AUTOR jest tabel¹ macierzyst¹ dla tabeli POZYCJE (klucz zewnêtrzny tabeli POZYCJE odnosi siê do klucza pierwotnego tabeli AUTOR, relacja ta wymusza spójnoœæ referencyjnej).

 import java.sql.*;

public class Cre1 {

  static public void main(String[] args) {
    new Cre1();
  }

Statement stmt; 

Cre1()  {
   Connection con = null;
   try {
      // ³¹czenie z baz¹ i utworzenie obiektu typu Statement
   } catch (Exception exc)  {
     System.out.println(exc);
     System.exit(1);
   }

   // metoda dropTable jest nasz¹ w³asn¹ metod¹ napisan¹ dla skrócenia programu
   // usuwa ona tabelê podan¹ jako argument
   // Aby w ka¿dych okolicznoœciach stworzyæ now¹ tabelê AUTOR
   // musimy usun¹æ ew.  ju¿ istniej¹c¹ tabelê AUTOR
   dropTable("POZYCJE"); // usuniêcie tabeli pochodnej, bêd¹cej w relacji z tabel¹ AUTOR
   dropTable("AUTOR");   // usuniêcie tabeli AUTOR

   String crestmt = ...

   try  {
     ....                  // wykonanie polecenia zapisanego w crestmt

   } catch (SQLException exc)  {                      // przechwycenie wyj¹tku:
      System.out.println("SQL except.: " + exc.getMessage());
      System.out.println("SQL state  : " + exc.getSQLState());
      System.out.println("Vendor errc: " + exc.getErrorCode());
      System.exit(1);
   } finally {
      try {
        stmt.close();
        con.close();
      } catch(SQLException exc) {
        System.out.println(exc);
        System.exit(1);
      }
   }
}

private void dropTable(String tname)  {
   // ....

}

Æwiczenie dodatkowe:
przywróciæ bazê danych do postaci wyjœciowej
skompilowaæ i wykonaæ program bez odwo³ania dropTable("POZYCJE")
obejrzeæ dok³adnie komunikaty o wyj¹tkach

Zadanie 12 (2p)
(Wpisywanie rekordów do tabeli)

a. Dodaæ do tabeli WYDAWCA rekordy reprezentuj¹ce jakichœ wydawców.

Przyk³ad ilustruje nastêpuj¹ce kwestie:
 instrukcja SQL do wpisywania ma postaæ INSERT...  (w kilka ró¿nych formach)
 przy wpisywaniu rekordów u¿ywamy executeUpdate(...)
 przy wpisywaniu i modyfikowaniu metoda ta zwraca liczbê wpisanych/zmodyfikowanych rekordów,
dane typu znakowego (CHAR, VARCHAR, LONGVARCHAR) s¹ podawane w SQL w apostrofach

 import java.sql.*;

public class Ins1 {

  static public void main(String[] args) {
    new Ins1();
  }

Statement stmt;

Ins1()  {
   Connection con = null;
   try {
     //...
   } catch (Exception exc)  {
     System.out.println(exc);
     System.exit(1);
   }
	// nazwy wydawców do wpisywania do tabeli
   String[] wyd =  { "PWN", "PWE", "Czytelnik", "Amber", "HELION", "MIKOM" };

   	// pierwszy numer wydawcy do wpisywania do tabeli: PWN ma numer 15, PWE ma 16, ...
   int beginKey = 15;

   String[] ins =  // ? ... tablica instrukcji SQL do wpisywania rekordów do tabeli: INSERT ...                  

   int insCount = 0;   // ile rekordów wpisano
   try  {
     for (int i=0; i < ins.length; i++) // wpisywanie rekordów
     // ...
   }
//...
}
} 
Dodatkowe æwiczenie:

    1. wykonaæ program ponownie i
    2. zobaczyæ jak naruszone jest ograniczenie jednoznacznoœci klucza pierwotnego

b. Usun¹æ z tabeli WYDAWCA rekordy z punktu a. za pomoc¹ prekompilowanych instrukcji.

Ta modyfikacja ilustruje u¿ycie instrukcji prekompilowanych:
instrukcja prekompilowana przygotowywana i wykonywana jest za pomoc¹ obiektu typu PreparedStatement
obiekt ten jest tworzony poprzez (inne!) odwo³anie do obiektu Connection: prepareStatement(...)
argumentem prepareStatement jest String, w którym wystêpuj¹ znaki zapytania – miejsca na "parametry" podstawiane przy kolejnych wykonaniach polecenia prekompilowanego
metody set...  interfejsu PreparedStatement  pozwalaj¹ podstawiaæ za parametry-znaki zapytania kolejne wartoœci
trzeba wiedzieæ jaki jest typ wartoœci (pola) i u¿yæ odpowiedniej metody set...
    // ...
   beginKey = 15,
   int delCount =  0;
   try  {
     // przygotowanie instrukcji prekompilowanej
     stmt = con.prepareStatement("DELETE FROM ...");	// usuniêcie z tabeli WYDAWCA rekordu o podanej nazwie wydawcy z tablicy wyd lub o podanym numerze wydawcy zaczynaj¹cym siê od beginKey 
     for (int i=0; i < wyd.length; i++)   {
       // ... ?
     }
     con.close();
   } catch(SQLException exc)  {
      System.out.println(exc);
   }

   // ...

Zadanie 13 (2p)
(SELECT i ResultSet)

Uwaga: Aby wykonaæ to zadanie nale¿y przywróciæ wyjœciow¹ wersjê bazy.

a. Wyprowadziæ z tabel POZYCJE, AUTOR dane o ksi¹¿kach wydanych po roku 2000 z cen¹ > 30 z³: nazwisko/a autora/ów,  tytu³, rok wydania, cena.
 
Program ma ilustrowaæ nastêpuj¹ce kwestie:
instrukcja SELECT wykonywana jest za pomoc¹ executeQuery(...)
executeQuery zwraca obiekt typy ResultSet (tzw. tabela wynikowa)
z ResultSet zwi¹zany jest tzw. kursor, który wskazuje bie¿¹cy rekord w tabeli wynikowej
inicjalnie kursor ustawiony jest przed pierwszym rekordem tabeli wynikowej
kursor mo¿emy przesuwaæ (tylko w stronê koñca tabeli, o ile nie wymagaliœmy tego, by ResultSet móg³ byæ "skrolowany") za pomoc¹ metody next() interfejsu ResultSet
wartoœci poszczególnych kolumn z bie¿¹cego rekordu mo¿emy pobraæ za pomoc¹ metod get...

    String sel = "SELECT ...";
   try  {
      Statement stmt = con.createStatement();
      ResultSet rs = stmt.executeQuery(sel);
      while (rs.next())  {
         String nawisko = // ... ?
         //...
         System.out.println("Autor: " + nazwisko);
         //...
   
      }
      stmt.close();
      con.close();
   } catch (SQLException exc)  {
     System.out.println(exc.getMessage());
   }

b. Wyprowadziæ wszystkie rekordy tabeli wynikowej powsta³ej na skutek wykonania instrukcji SELECT od koñca tabeli, a nastêpnie wyprowadziæ rekordy 3, 7 i 9.

To zadanie winno zilustrowaæ:
przewijalny ResultSet (typ deklarujemy w createStatement)
absolutne pozycjonowanie w ramach tabeli wynikowej
u¿ycie metainformacji o kolumnach tabeli wynikowej (obiekt typu ResultSetMetaData mo¿emy uzyskaæ za pomoc¹ zlecenia wobec ResultSet – getMetaData(), nastêpnie mo¿emy go "odpytaæ" o ró¿ne informacje za pomoc¹ metod interfejsu ResultSetMetaData)
uniwersalnoœæ metody getString: jeœli potrzebna nam tylko znakowa reprezentacja informacji zawartej w kolumnach tabeli, getString (u¿yte wobec bie¿¹cego rekordu ResultSet) dokona w³aœciwej konwersji dla ka¿dego typu danych w BD (oprócz typów definiowanych i SQL3)

   String sel = // ... ?
   try  {
      Statement stmt = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
                                           ResultSet.CONCUR_READ_ONLY);
      ResultSet rs = stmt.executeQuery(sel);
      ResultSetMetaData rsmd = rs.getMetaData();
      int cc = rsmd.getColumnCount();
      for (int i = 1; i <= cc; i++)
        System.out.print(rsmd.getColumnLabel(i) + "     ");

      System.out.println("\n------------------------------ przewijanie do góry");

      // ... ?
 
      System.out.println("\n----------------------------- pozycjonowanie abs.");
      int[] poz =  { 3, 7, 9  };
      for (int p = 0; p < poz.length; p++)  {
         System.out.print("[ " + poz[p] + " ] ");
         // ... ?
         for (int i = 1; i <= cc; i++) System.out.print(rs.getString(i) + ", ");
         System.out.println("");
      }
      stmt.close();
      con.close();
   } catch (SQLException exc)  {
     System.out.println(exc.getMessage());
   }